%{
#include <stdio.h>
#include <string.h>
#define MAX_STR_LEN	100
int yylex(void);
void yyerror(const char *txt);
void found(const char *nonterminal, const char *value);
%}

%union {
	char s[MAX_STR_LEN + 1];
	int i;
	double d;
}

%start GRAMMAR
/* keywords */
%token <i> KW_ARRAY KW_AND KW_BEGIN KW_CASE KW_CONST KW_DIV KW_DO KW_DOWNTO KW_ELSE KW_ELSIF KW_END KW_FOR KW_FROM KW_IF KW_IMPORT KW_IN KW_LOOP KW_MOD KW_MODULE KW_NOT KW_OF KW_OR KW_PROCEDURE KW_RECORD KW_REPEAT KW_THEN KW_TO KW_TYPE KW_UNTIL KW_VAR KW_WHILE
/* literal values */
%token <s> STRING_CONST CHAR_CONST
%token <i> INTEGER_CONST
%token <d> FLOAT_CONST
/* operators */
%token <i> ASSIGN LE GE NEQ RANGE
/* other */
%token <s> IDENT

%left '+' '-' KW_OR
%left '*' '/' KW_DIV KW_MOD KW_AND '&'
%left NEG KW_NOT

%%

/* GRAMMAR */
GRAMMAR:
	{ yyerror( "Empty input source is not valid!" ); YYERROR; }
	| error
	| PROGRAM_MODULE;  /* { found("Valid grammar!", ""); }; */

/* PROGRAM_MODULE */
PROGRAM_MODULE: KW_MODULE IDENT ';' IMPORTS BLOCK IDENT '.'
	{ found("PROGRAM_MODULE", $2); };

/* IMPORTS */
IMPORTS: /* Nothing */ | IMPORTS IMPORT;

/* IMPORT */
IMPORT: KW_FROM IDENT KW_IMPORT IDENT_LIST ';'
	{ found("IMPORT", $2); };

/* IDENT_LIST */
IDENT_LIST: IDENT | IDENT_LIST ',' IDENT;

/* BLOCK */
BLOCK: DECLARATIONS KW_BEGIN STATEMENTS KW_END | DECLARATIONS KW_END;

/* DECLARATIONS */
DECLARATIONS: /* Nothing */ | DECLARATIONS DECLARATION;

/* DECLARATION */
DECLARATION: KW_CONST CONST_DECLS | KW_VAR VAR_DECLS | PROC_DECL ';';

/* CONST_DECLS */
CONST_DECLS: /* Nothing */ | CONST_DECLS CONST_DECL ';';

/* CONST_DECL */
CONST_DECL: IDENT '=' CONST_FACTOR
	{ found("CONST_DECL", $1); };

/* CONST_FACTOR */
CONST_FACTOR: IDENT | INTEGER_CONST | FLOAT_CONST | STRING_CONST | CHAR_CONST;

/* VAR_DECLS */
VAR_DECLS: /* Nothing */ | VAR_DECLS VAR_DECL ';';

/* VAR_DECL */
VAR_DECL: IDENT_LIST ':' TYPE_SPEC
	{ found("VAR_DECL", ""); };

/* TYPE_SPEC */
TYPE_SPEC:
	IDENT
	| KW_ARRAY DIMEN_SPECS KW_OF TYPE_SPEC
	| KW_RECORD FIELDS KW_END;

/* DIMEN_SPECS */
DIMEN_SPECS: DIMEN_SPEC | DIMEN_SPECS ',' DIMEN_SPEC;

/* DIMEN_SPEC */
DIMEN_SPEC: '[' CONST_FACTOR RANGE CONST_FACTOR ']';

/* FIELDS */
FIELDS: /* Nothing */ | FIELDS FIELD ';';

/* FIELD */
FIELD: IDENT_LIST ':' TYPE_SPEC;

/* PROC_DECL */
PROC_DECL: PROC_HEAD ';' BLOCK IDENT
	{ found("PROC_DECL", $4); };

/* PROC_HEAD */
PROC_HEAD: KW_PROCEDURE IDENT OPT_FORMAL_PARAMS
	{ found("PROC_HEAD", $2); };

/* OPT_FORMAL_PARAMS */
OPT_FORMAL_PARAMS: /* Nothing */ | FORMAL_PARAMS;

/* FORMAL_PARAMS */
FORMAL_PARAMS: '(' FP_SECTIONS ')' OPT_RET_TYPE;

/* FP_SECTIONS */
FP_SECTIONS: FP_SECTION | FP_SECTIONS ';' FP_SECTION;

/* FP_SECTION */
FP_SECTION: OPT_VAR IDENT_LIST ':' QUALIDENT
	{ found("FP_SECTION", ""); };

/* OPT_VAR */
OPT_VAR: /* Nothing */ | KW_VAR;

/* OPT_RET_TYPE */
OPT_RET_TYPE: /* Nothing */ | ':' QUALIDENT;

/* QUALIDENT */
QUALIDENT: IDENT | QUALIDENT '.' IDENT;

/* STATEMENTS */
STATEMENTS: STATEMENT | STATEMENTS ';' STATEMENT;

/* STATEMENT */
STATEMENT:
	PROCEDURE_CALL
	| ASSIGNMENT
	| FOR_STATEMENT
	| IF_STATEMENT
	| WHILE_STATEMENT
	| REPEAT_STATEMENT
	| LOOP_STATEMENT
	| CASE_STATEMENT;

/* ASSIGNMENT */
ASSIGNMENT: IDENT QUALIF ASSIGN EXPR
	{ found("ASSIGNMENT", $1); };

/* QUALIF */
QUALIF: /* Nothing */ | '[' SUBSCRIPTS ']' QUALIF | '.' IDENT QUALIF;

/* SUBSCRIPTS */
SUBSCRIPTS: EXPR | SUBSCRIPTS ',' EXPR;

/* PROCEDURE_CALL */
PROCEDURE_CALL:
	IDENT
		{ found("PROCEDURE_CALL", $1); }
	| IDENT '(' ACT_PARAMETERS ')'
		{ found("PROCEDURE_CALL", $1); };

/* ACT_PARAMETERS */
ACT_PARAMETERS: EXPR | ACT_PARAMETERS ',' EXPR;

/* EXPR */
EXPR: SIMPLE_EXPR | SIMPLE_EXPR REL_OP SIMPLE_EXPR;

/* REL_OP */
REL_OP: '=' | '<' | '>' | '#' | NEQ | LE | GE | KW_IN;

/* SIMPLE_EXPR */
SIMPLE_EXPR:
	FACTOR
	| SIMPLE_EXPR '+' SIMPLE_EXPR
	| SIMPLE_EXPR '-' SIMPLE_EXPR
	| SIMPLE_EXPR KW_OR SIMPLE_EXPR
	| SIMPLE_EXPR '*' SIMPLE_EXPR
	| SIMPLE_EXPR '/' SIMPLE_EXPR
	| SIMPLE_EXPR KW_AND SIMPLE_EXPR
	| SIMPLE_EXPR KW_DIV SIMPLE_EXPR
	| SIMPLE_EXPR KW_MOD SIMPLE_EXPR;

/* FACTOR */
FACTOR: INTEGER_CONST | FLOAT_CONST | STRING_CONST | CHAR_CONST | IDENT QUALIF | PROCEDURE_CALL | '(' EXPR ')' | KW_NOT FACTOR %prec NEG | '-' FACTOR; 

/* FOR_STATEMENT */
FOR_STATEMENT: KW_FOR IDENT ASSIGN EXPR TO_DOWNTO EXPR KW_DO STATEMENTS KW_END
	{ found("FOR_STATEMENT", $2); };

/* TO_DOWNTO */
TO_DOWNTO: KW_TO | KW_DOWNTO;

/* IF_STATEMENT */
IF_STATEMENT: KW_IF EXPR KW_THEN STATEMENTS ELSIFS ELSE_PART KW_END
	{ found("IF_STATEMENT", ""); };

/* ELSIFS */
ELSIFS: /* Nothing */ |/*  ELSIFS */ KW_ELSIF EXPR KW_THEN STATEMENTS;

/* ELSE_PART */
ELSE_PART: /* Nothing */ | KW_ELSE STATEMENTS;

/* WHILE_STATEMENT */
WHILE_STATEMENT: KW_WHILE EXPR KW_DO STATEMENTS KW_END
	{ found("WHILE_STATEMENT", ""); };

/* REPEAT_STATEMENT */
REPEAT_STATEMENT: KW_REPEAT STATEMENTS KW_UNTIL EXPR
	{ found("REPEAT_STATEMENT", ""); };

/* LOOP_STATEMENT */
LOOP_STATEMENT: KW_LOOP STATEMENTS KW_END
	{ found("LOOP_STATEMENT", ""); };

/* CASE_STATEMENT */
CASE_STATEMENT: KW_CASE EXPR KW_OF CASES ELSE_PART KW_END
	{ found("CASE_STATEMENT", ""); };

/* CASES */
CASES: CASE_LABELS ':' STATEMENTS | CASES '|' CASE_LABELS ':' STATEMENTS;

/* CASE_LABELS */
CASE_LABELS: CASE_LABEL | CASE_LABELS ',' CASE_LABEL;

/* CASE_LABEL */
CASE_LABEL: INTEGER_CONST | STRING_CONST | CHAR_CONST;

%%

int main(void) {
	printf("Kamil Lubarski\n");
	printf("yytext              Token type      Token value as string\n\n");
	yyparse();
	return(0);
}

void yyerror(const char *txt) {
	printf("%s\n", txt);
}

void found(const char *nonterminal, const char *value) {
	printf("===== FOUND: %s %s%s%s=====\n", nonterminal, (*value) ? "'" : "", value, (*value) ? "'" : "");
}
